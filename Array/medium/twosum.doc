
The 2-Sum Problem: A Story-Based Explanation
Imagine you are a shopkeeper ğŸª who sells different types of chocolates ğŸ«.
Each chocolate has a price (an array of numbers).

One day, a customer walks in and says:
ğŸ’¬ "I have â‚¹K. Can you give me two chocolates whose prices add up to exactly â‚¹K?"

Your job? Find two chocolates in your shop whose total price matches K.

Approach 1ï¸âƒ£: Brute Force â€“ The Exhausted Shopkeeper ğŸ˜µâ€ğŸ’«
ğŸ’¡ How does the shopkeeper think?
He is not very smart. He checks every possible pair of chocolates to see if their total price matches K.

ğŸ¹ How does he do it?

He picks the first chocolate ğŸ« and checks it with every other chocolate ğŸ«ğŸ«.
If their total price == K, he gives them to the customer. âœ…
Otherwise, he repeats this for every chocolate in the shop.
ğŸ“œ Pseudo Code

java
Copy
Edit
class Solution {
    public int[] twoSum(int[] prices, int K) {
        for (int i = 0; i < prices.length; i++) {
            for (int j = i + 1; j < prices.length; j++) {
                if (prices[i] + prices[j] == K) { // Found a match!
                    return new int[]{i, j}; // Return the indices
                }
            }
        }
        return new int[]{-1, -1}; // No match found
    }
}
â³ Time Complexity: O(NÂ²) â†’ Checks every pair (too slow for big shops).
ğŸ›‘ Why is it bad?

Too slow! The shopkeeper takes forever checking all pairs. â³
He repeats the same calculations again and again.
Approach 2ï¸âƒ£: Better Approach (HashMap) â€“ The Smart Shopkeeper ğŸ˜
ğŸ’¡ How does he think now?
The shopkeeper is now smart! He remembers chocolates he has already seen using a notebook ğŸ“’ (HashMap).

ğŸ¹ How does he do it?

He checks if the required chocolate price (K - current price) exists in his notebook ğŸ“’.
If yes, he found a pair! âœ…
Otherwise, he writes down the price of each chocolate as he goes.
ğŸ“œ Pseudo Code

java
Copy
Edit
import java.util.*;

class Solution {
    public int[] twoSum(int[] prices, int K) {
        Map<Integer, Integer> map = new HashMap<>(); // Store {price, index}

        for (int i = 0; i < prices.length; i++) {
            int remaining = K - prices[i]; // The price we need to find

            if (map.containsKey(remaining)) { // Check if the remaining price exists
                return new int[]{map.get(remaining), i}; // Return indices
            }

            map.put(prices[i], i); // Store the price and index
        }
        return new int[]{-1, -1}; // No match found
    }
}
â³ Time Complexity: O(N) â†’ Only one pass through the chocolates.
ğŸ“¦ Space Complexity: O(N) â†’ Uses extra space for the notebook (HashMap).

âœ… Why is this better?

The shopkeeper remembers what he has seen (HashMap ğŸ“’), so he doesn't check everything again.
He finds the answer in one pass (FAST ğŸš€).
Approach 3ï¸âƒ£: Optimal Approach (Sorting + Two-Pointer) â€“ The Genius Shopkeeper ğŸ“
ğŸ’¡ How does the genius shopkeeper think?
He sorts the chocolates by price first! Then, he uses two people (pointers ğŸ‘ˆğŸ‘‰) to find the correct pair.

ğŸ¹ How does he do it?
1ï¸âƒ£ First, he sorts all chocolates by price (Sorting ğŸ›’).
2ï¸âƒ£ He starts with two people:

One at the cheapest chocolate ğŸ« (left pointer).
One at the most expensive chocolate ğŸ« (right pointer).
3ï¸âƒ£ He checks their total price:
If sum > K â†’ Too expensive! Move the right pointer left.
If sum < K â†’ Too cheap! Move the left pointer right.
If sum == K â†’ Found the answer! âœ…
ğŸ“œ Pseudo Code

java
Copy
Edit
import java.util.*;

class Solution {
    public int[] twoSum(int[] prices, int K) {
        Arrays.sort(prices); // Step 1: Sort the array
        int left = 0, right = prices.length - 1; // Step 2: Two pointers

        while (left < right) {
            int sum = prices[left] + prices[right];

            if (sum == K) { // Step 3: Found the pair!
                return new int[]{left, right};
            } else if (sum < K) {
                left++; // Move left pointer (increase sum)
            } else {
                right--; // Move right pointer (decrease sum)
            }
        }
        return new int[]{-1, -1}; // No match found
    }
}
â³ Time Complexity: O(N log N) â†’ Because of sorting.
ğŸ“¦ Space Complexity: O(1) â†’ No extra storage needed.

âœ… Why is this even better?

If sorting is already done, it's the fastest!
Does not use extra memory (no HashMap needed).
Comparison of All Approaches
Approach	Time Complexity	Space Complexity	Best When?
Brute Force	O(NÂ²)	O(1)	For very small arrays (â‰¤ 100 elements)
HashMap (Better)	O(N)	O(N)	For large arrays when space is not a problem
Sorting + Two Pointers (Optimal)	O(N log N)	O(1)	When sorting is allowed & extra space is limited
Final Thoughts
ğŸ“ If array is small, Brute Force is fine.
ğŸ“ If array is large, use HashMap for speed.
ğŸ“ If sorting is okay, Two-Pointer is best because it uses no extra space.

ğŸš€ Genius Shopkeepers use HashMap or Two-Pointer techniques!